{"version":3,"sources":["assembly/index.ts"],"names":[],"mappings":"qJAUI,AAAW,EAA0B,AAAC,EAAgB,IAAiB,WAqCzE,AAAQ,IACR,AAAS,IACT,AAAO,EAAQ,KACf,AAAqB,EAAS,AAAI,EAAJ,MAC9B,AAAqB,IACrB,AAAqB,EAAS,AAAK,EAAL,MAC9B,AAAqB,EAAS,AAAK,EAAL,MAC9B,AAAqB,EAAS,AAAK,EAAL,MAC9B,AAAmB,EAAS,AAAK,EAAL,QACZ,EAAI,KAClB,EAAO,EAAI,GAAS,IACpB,EAAO,AAAY,EAAZ,EAAI,IAAgB,OAFD,AAAE,WAKzB,AAAQ,MAAG,EAAI,KAClB,EAAO,EAAK,IACZ,EAAO,EAAO,GAAQ,OAFG,AAAE,cAvDgD,AAA1D,EAA0B,AAAC,EAAgB,eAgE9D,EAAgB,EAAI,KAClB,AAAI,EAAO,SACT,EAAE,EAAK,IACP,EAAE,EAAK,IACP,EAAM,EAAK,KAEb,AAAI,EAAO,SACT,EAAE,EAAK,EAAC,KACR,EAAE,EAAK,IACP,EAAM,EAAK,KATW,WAarB,AAAQ,MAAb,EAAgB,EAAI,KAClB,AAAI,EAAO,OACT,AAAa,EAAE,MACf,AAAa,EAAE,EAAI,OACnB,AAAa,EAAE,EAAI,OAInB,AAAU,AAAC,AAAC,AAHC,EAAE,EAAI,KACN,EAAE,EAAI,MAEc,GAAK,KAGtC,AAAU,EAAE,IAAK,AAAC,EAAO,IAAK,AAFpB,AAAC,AAAC,AAAC,EAAS,GAAW,GAAK,GAEA,MACtC,AAAI,IAAiB,AACnB,EAAO,AAAC,EAAO,OAEjB,EAAE,uCAfoB,AAAE,WAmBvB,AAAQ,MAAb,EAAgB,EAAI,KAClB,AAAI,EAAO,OACT,AAAQ,EAAM,MACd,YAAsB,EAAE,IAAK,EAAE,6BAC/B,EAAE,EAzF2E,AAAnE,MAAa,AAAO,MAyFd,EAAI,KAzFyB,EAAI,QAAa,EAAI,UA0FlE,EAAM,EAAN,MAAY,AAAC,SALS,AAAE,WASvB,AAAQ,MAAb,EAAgB,EAAI,KAClB,AAAI,EAAO,SAAoB,AAC7B,EAAM,EAAK,KACN,AACL,EAAM,EA1FmE,AAAtE,AAAO,EAAC,AAHf,AAAU,AA6FW,EAAE,IA7FR,KAGO,IAAM,GAAI,AAAC,EAAM,AAAC,EAAO,IAAK,AAAC,EAAO,IAAM,EAAM,IAAK,SAsFnD,AAAE","sourceRoot":"assemblyscript:///","sourceContents":["class Pointer {\n  constructor(offset: usize = 0) {\n    return changetype<Pointer>(offset);\n  }\n\n  @inline @operator(\"[]\") get(index: i32): i32 {\n    return load<i32>(changetype<usize>(this) + (<usize>index << alignof<i32>()));\n  }\n\n  @inline @operator(\"[]=\") set(index: i32, value: i32): void {\n    store<i32>(changetype<usize>(this) + (<usize>index << alignof<i32>()), value);\n  }\n}\n\n// Full int32 range is -0x80000000 to 0x7FFFFFFF. Use half.\n@inline function applyCap(x: i32): i32 {\n  // return x < -0x40000000 ? -0x40000000 : (x > 0x3FFFFFFF ? 0x3FFFFFFF : x);\n  return select(-0x40000000, select(0x3FFFFFFF, x, x > 0x3FFFFFFF), x < -0x40000000);\n}\n\n@inline function toRGB(x: i32): i32 {\n  // Map negative values to red, positive to blue-green, zero to black\n  var val = x >> 22;\n  // if (val < 0) return ((-(val + 1))  | 0xFF000000); // red\n  // return (((val << 8) | (val << 16)) | 0xFF000000); // cyan\n  return select(-(val + 1) << 16, (val | (val << 8) | (val << 16)), val < 0) | 0xFF000000;\n}\n\nconst STATUS_DEFAULT: i32 = 0;\nconst STATUS_WALL: i32 = 1;\nconst STATUS_POS_TRANSMITTER: i32 = 2;\nconst STATUS_NEG_TRANSMITTER: i32 = 3;\n\nconst FORCE_DAMPING_BIT_SHIFT: i32 = 4;\n\nlet width: i32 = 0;\nlet height: i32 = 0;\nlet area: i32 = 0;\n\nlet image:Pointer = null;\nlet force:Pointer = null;\nlet status:Pointer = null;\nlet u:Pointer = null;\nlet v:Pointer = null;\n\nexport function init(ignored: i32, offset: i32, w: i32, h: i32): void {\n\n  width = w;\n  height = h;\n  area = width * height;\n  status = new Pointer(offset + 8 * area);\n  image  = new Pointer(offset);\n  force  = new Pointer(offset + 4  * area);\n  status = new Pointer(offset + 8  * area);\n  u      = new Pointer(offset + 12 * area);\n  v    = new Pointer(offset + 16 * area);\n  for (let i = 0; i < height; ++i) {\n    status[i * width] = 1;\n    status[i * width + width - 1] = STATUS_WALL;\n  }\n\n  for (let i = 0; i < width; ++i) {\n    status[i] = 1;\n    status[area - width + i] = STATUS_WALL;\n  }\n}\n\nexport function step(signalAmplitude: i32, dampingBitShift: i32): void {\n\n  // First loop: look for noise generator pixels and set their values in u\n  for (let i = 0; i < area; i++) {\n    if (status[i] === STATUS_POS_TRANSMITTER) {\n      u[i] = signalAmplitude;\n      v[i] = 0;\n      force[i] = 0;\n    }\n    if (status[i] === STATUS_NEG_TRANSMITTER) {\n      u[i] = -signalAmplitude;\n      v[i] = 0;\n      force[i] = 0;\n    }\n  }\n\n  for (let i = 0; i < area; ++i) {\n    if (status[i] === STATUS_DEFAULT) {\n      let uCen   = u[i];\n      let uNorth = u[i - width];\n      let uSouth = u[i + width];\n      let uEast  = u[i + 1];\n      let uWest  = u[i - 1];\n\n      let uxx = (((uWest  + uEast)  >> 1) - uCen);\n      let uyy = (((uNorth + uSouth) >> 1) - uCen);\n\n      let vel = v[i] + (uxx >> 1) + (uyy >> 1);\n      if (dampingBitShift) {\n        vel -= (vel >> dampingBitShift);\n      }\n      v[i] = applyCap(vel);\n    }\n  }\n\n  for (let i = 0; i < area; ++i) {\n    if (status[i] === STATUS_DEFAULT) {\n      let f = force[i];\n      let capped = applyCap(u[i] + v[i]);\n      u[i] = applyCap(f + capped);\n      force[i] -= (f >> FORCE_DAMPING_BIT_SHIFT);\n    }\n  }\n\n  for (let i = 0; i < area; ++i) {\n    if (status[i] === STATUS_WALL) {\n      image[i] = 0x00000000;\n    } else {\n      image[i] = toRGB(u[i]);\n    }\n  }\n}\n"]}