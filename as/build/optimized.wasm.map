{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","assembly/index.ts","~lib/rt/stub.ts"],"names":[],"mappings":"6GEqDE,AAAS,IACT,AAAS,IACT,AAAS,EAAQ,KACjB,AAAS,IACT,AAAS,AAAY,EAAU,AAAI,EAAJ,MAC/B,AAAS,AAAY,EAAU,AAAI,EAAJ,MAC/B,AAAS,AAAY,EAAS,AAAK,EAAL,MAC9B,AAAS,AAAY,EAAS,AAAK,EAAL,MAEzB,AAAQ,MAAG,EAAI,KAClB,IAAO,EAAI,WAAS,KACpB,EAAO,AAAY,EAAZ,GAAoB,OAAK,KAFN,AAAE,WAKzB,AAAQ,MAAG,EAAI,KAClB,UAAY,KACZ,AArDW,EAA2B,AAqDhB,EAAf,EAAO,IArDwC,IAAiB,KAmD9C,AAAE,iBAQnB,ICSV,oBDHW,MAGK,EAAI,KAElB,AAAI,AADI,aACE,KACR,UAAQ,KACR,UACA,WAEF,AAAI,EAAM,KACR,UAAQ,EAAC,MACT,UACA,WAVuB,AAAE,WAcxB,AAAQ,MAAG,EAAI,KAClB,AAAI,cACW,eAUb,AAAqB,AADX,UAAS,AAHP,AAAC,AAAS,EAHN,EAAI,UAGP,EAFG,EAAI,WAEa,GAAK,GAGZ,IAAM,AAFpB,AAAC,EANG,EAAI,UAME,AALT,EAAG,EAAI,WAKa,GAAK,GAEC,MACX,EAAO,MAA/B,KACJ,EAAQ,YAAS,0BAbM,AAAE,WAiBxB,AAAQ,MAAG,EAAI,KAElB,AAAQ,eACR,AAAI,AAFO,aAGD,iBAGR,KAAQ,AADJ,AAlGiB,MAAe,AAAiB,MAAa,AAkGrD,EAAI,YADK,EAAI,AA5GX,AAA2B,EAA3B,gCAWqB,EAAI,QAArC,EAAI,aAoGP,EAAY,EAAK,EAAK,QAExB,AAAI,EAAS,KACX,QAAY,MAhGK,AAAC,EAAE,AADd,EAAK,KACe,MAAO,AAAC,AAAC,EAAc,IAAS,IAAM,QAkGhE,AAhHS,EAA2B,EAAgB,IAcpD,EAAM,KACV,AAAS,AAAC,EAAO,GAAM,AAAC,EAAM,IAAS,IAAO,cAoFnB,AAAE","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","/// <reference path=\"../node_modules/assemblyscript/index.d.ts\" />\n\n@final\nclass Pointer {\n  // just need for making tslint happy\n  [key: number]: number;\n\n  constructor(offset: usize = 0) {\n    return changetype<Pointer>(offset);\n  }\n\n  @inline @operator(\"[]\") get(index: i32): i32 {\n    return load<i32>(changetype<usize>(this) + (<usize>index << alignof<i32>()));\n  }\n\n  @inline @operator(\"[]=\") set(index: i32, value: i32): void {\n    store<i32>(changetype<usize>(this) + (<usize>index << alignof<i32>()), value);\n  }\n}\n\n// Full int32 range is -0x80000000 to 0x7FFFFFFF. Use half.\n// @ts-ignore: decorator\n@inline function applyCap(x: i32): i32 {\n  return x < -0x40000000 ? -0x40000000 : (x > 0x3FFFFFFF ? 0x3FFFFFFF : x);\n}\n\n// @ts-ignore: decorator\n@inline function toRGB(x: i32): i32 {\n  // Map negative values to pink, positive to pale green, zero to black\n  var val = x >> 22;\n  if (val < 0) return ((-(val + 1)) | (((-(val + 1)) & 0xFE) << 15) | 0xFF000000); // pink\n  return (((val << 8) | ((val & 0xFE) << 15)) | 0xFF000000); // pale green\n}\n\nconst STATUS_DEFAULT = 0;\nconst STATUS_WALL = 1;\nconst STATUS_POS_TRANSMITTER = 2;\nconst STATUS_NEG_TRANSMITTER = 3;\n\nconst FORCE_DAMPING_BIT_SHIFT = 4;\n\nlet width = 0;\nlet height = 0;\nlet area = 0;\n\nlet image:  Pointer;\nlet force:  Pointer;\nlet status: Pointer;\nlet u:      Pointer;\nlet v:      Pointer;\n\nexport function init(_ignored: i32, offset: i32, w: i32, h: i32): void {\n\n  width  = w;\n  height = h;\n  area   = width * height;\n  image  = new Pointer(offset);\n  force  = new Pointer(offset +  4 * area);\n  status = new Pointer(offset +  8 * area);\n  u      = new Pointer(offset + 12 * area);\n  v      = new Pointer(offset + 16 * area);\n\n  for (let i = 0; i < height; ++i) {\n    status[i * width] = STATUS_WALL;\n    status[i * width + width - 1] = STATUS_WALL;\n  }\n\n  for (let i = 0; i < width; ++i) {\n    status[i] = STATUS_WALL;\n    status[area - width + i] = STATUS_WALL;\n  }\n}\n\nexport function step(signalAmplitude: i32, dampingBitShift: i32): void {\n  let\n    _area = area,\n    _status = status,\n    _u = u,\n    _v = v,\n    _force = force,\n    _image = image,\n    _width = width;\n\n  // First loop: look for noise generator pixels and set their values in u\n  for (let i = 0; i < _area; ++i) {\n    let s = _status[i];\n    if (s === STATUS_POS_TRANSMITTER) {\n      _u[i] = signalAmplitude;\n      _v[i] = 0;\n      _force[i] = 0;\n    }\n    if (s === STATUS_NEG_TRANSMITTER) {\n      _u[i] = -signalAmplitude;\n      _v[i] = 0;\n      _force[i] = 0;\n    }\n  }\n\n  for (let i = 0; i < _area; ++i) {\n    if (_status[i] === STATUS_DEFAULT) {\n      let uCen   = _u[i];\n      let uNorth = _u[i - _width];\n      let uSouth = _u[i + _width];\n      let uEast  = _u[i + 1];\n      let uWest  = _u[i - 1];\n\n      let uxx = (((uWest  + uEast)  >> 1) - uCen);\n      let uyy = (((uNorth + uSouth) >> 1) - uCen);\n\n      let vel = _v[i] + (uxx >> 1) + (uyy >> 1);\n      if (dampingBitShift) vel -= vel >> dampingBitShift;\n      _v[i] = applyCap(vel);\n    }\n  }\n\n  for (let i = 0; i < _area; ++i) {\n    let stat = _status[i];\n    let u = _u[i];\n    if (stat === STATUS_DEFAULT) {\n      let f = _force[i];\n      let capped = applyCap(u + _v[i]);\n      u = applyCap(f + capped);\n      _u[i] = u;\n      _force[i] = f - (f >> FORCE_DAMPING_BIT_SHIFT);\n    }\n    if (stat === STATUS_WALL) {\n      _image[i] = 0x00000000;\n    } else {\n      _image[i] = toRGB(u);\n    }\n  }\n}\n","import { AL_MASK, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE, AL_SIZE, DEBUG } from \"rt/common\";\n\n// @ts-ignore: decorator\n@lazy var startOffset: usize = (__heap_base + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@lazy var offset: usize = startOffset;\n\nfunction maybeGrowMemory(newOffset: usize): void {\n  // assumes newOffset is aligned\n  var pagesBefore = memory.size();\n  var maxOffset = <usize>pagesBefore << 16;\n  if (newOffset > maxOffset) {\n    let pagesNeeded = <i32>(((newOffset - maxOffset + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newOffset;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize, id: u32): usize {\n  if (size > BLOCK_MAXSIZE) unreachable();\n  var ptr = offset + BLOCK_OVERHEAD;\n  var actualSize = max<usize>((size + AL_MASK) & ~AL_MASK, AL_SIZE);\n  maybeGrowMemory(ptr + actualSize);\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  block.mmInfo = actualSize;\n  if (DEBUG) block.gcInfo = 1;\n  block.rtId = id;\n  block.rtSize = <u32>size;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ptr: usize, size: usize): usize {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  var actualSize = block.mmInfo;\n  if (DEBUG) assert(block.gcInfo == 1);\n  var isLast = ptr + actualSize == offset;\n  var alignedSize = (size + AL_MASK) & ~AL_MASK;\n  if (size > actualSize) {\n    if (isLast) { // last block: grow\n      if (size > BLOCK_MAXSIZE) unreachable();\n      maybeGrowMemory(ptr + alignedSize);\n      block.mmInfo = alignedSize;\n    } else { // copy to new block at least double the size\n      let newPtr = __alloc(max<usize>(alignedSize, actualSize << 1), block.rtId);\n      memory.copy(newPtr, ptr, block.rtSize);\n      block = changetype<BLOCK>((ptr = newPtr) - BLOCK_OVERHEAD);\n    }\n  } else if (isLast) { // last block: shrink\n    offset = ptr + alignedSize;\n    block.mmInfo = alignedSize;\n  }\n  block.rtSize = <u32>size;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ptr: usize): void {\n  assert(ptr != 0 && !(ptr & AL_MASK)); // must exist and be aligned\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  if (DEBUG) assert(block.gcInfo == 1);\n  if (ptr + block.mmInfo == offset) { // last block: discard\n    offset = changetype<usize>(block);\n  }\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ref: usize): usize {\n  return ref;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ref: usize): void {\n  /* nop */\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __visit(ref: usize, cookie: u32): void { // eslint-disable-line @typescript-eslint/no-unused-vars\n  /* nop */\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  /* nop */\n}\n"]}