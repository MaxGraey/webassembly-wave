{"version":3,"sources":["assembly/index.ts"],"names":[],"mappings":"mLAOqC,KAQjC,AAAW,EAA0B,AAAC,EAAgB,IAAiB,WAmCzE,AAAS,IACT,AAAS,IACT,AAAS,EAAQ,KACjB,AAAS,EAAY,MACrB,AAAS,EAAY,EAAS,EAAK,QACnC,AAAS,EAAY,EAAS,EAAK,QACnC,AAAS,EAAY,EAAS,EAAK,QACnC,AAAS,EAAY,EAAS,EAAK,QAEnC,EAAK,AAAQ,MAAG,EAAI,MAAa,EAC/B,EAAO,EAAI,GAAS,IACpB,EAAO,EAAI,GAAQ,GAAQ,GAAK,KAFN,AAAE,aAK9B,EAAK,AAAQ,MAAG,EAAI,MAAY,EAC9B,EAAO,EAAK,IACZ,EAAO,EAAO,GAAQ,GAAK,KAFF,AAAE,mBAOjB,IACA,IACL,IACA,IACI,IACA,IACA,IAGX,EAAK,AAAQ,MAAG,EAAI,MAAY,EAC9B,AAAQ,MAAQ,kBAChB,AAAI,EAAM,KACR,EAAG,EAAK,IACR,EAAG,EAAK,IACR,EAAO,EAAK,KAEd,AAAI,EAAM,KACR,EAAG,EAAK,EAAC,KACT,EAAG,EAAK,IACR,EAAO,EAAK,MAVW,AAAE,aAc7B,EAAK,AAAQ,MAAG,EAAI,MAClB,AAAI,MAAQ,gBAAO,KACjB,AAAa,MAAG,kBAChB,AAAa,MAAG,EAAI,mBACpB,AAAa,MAAG,EAAI,mBACpB,AAAa,MAAG,EAAI,mBACpB,AAAa,MAAG,EAAI,mBAEpB,AAAU,AAAC,AAAC,AAAC,EAAS,GAAW,GAAK,KACtC,AAAU,AAAC,AAAC,AAAC,EAAS,GAAW,GAAK,KAEtC,AAAU,MAAG,gBAAK,AAAC,EAAO,IAAK,AAAC,EAAO,MACvC,AAAI,IAAiB,EAAO,EAAO,OACnC,EAAG,EAAK,EAAS,gDAbM,AAAE,aAkB7B,EAAK,AAAQ,MAAG,EAAI,MAAY,EAC9B,AAAO,MAAQ,kBACf,AAAI,EAAS,KACX,AAAI,MAAO,kBACX,AAAI,MAAG,kBACP,AAAS,EAAS,EAAI,MAAG,IA1GgD,AAA1D,EAA0B,AAAC,EAAgB,sDA2G1D,AAAI,EAAS,EAAI,KAjGkD,AAAhE,EAAI,SAAc,OAAc,AAAC,EAAI,SAAa,OAAa,OAkGlE,EAAG,EAAK,IACR,EAAO,EAAK,EAAI,AAAC,EAAK,OAExB,AAAI,EAAS,KAAa,AACxB,EAAO,EAAK,KACP,AACL,EAAO,EAAK,EAAM,IAnGtB,AAAU,EAAK,KACf,AAAI,EAAM,KAAqC,AAA3B,AAAC,EAAE,AAAC,EAAM,IAAO,SACU,AAAvC,AAAC,AAAC,EAAO,GAAK,AAAC,EAAO,IAAO,WAoFV,AAAE","sourceRoot":"assemblyscript:///","sourceContents":["/// <reference path=\"../node_modules/assemblyscript/index.d.ts\" />\n\nclass Pointer {\n  // just need for making tslint happy\n  [key: number]: number;\n\n  constructor(offset: usize = 0) {\n    return changetype<Pointer>(offset);\n  }\n\n  @inline @operator(\"[]\") get(index: i32): i32 {\n    return load<i32>(changetype<usize>(this) + (<usize>index << alignof<i32>()));\n  }\n\n  @inline @operator(\"[]=\") set(index: i32, value: i32): void {\n    store<i32>(changetype<usize>(this) + (<usize>index << alignof<i32>()), value);\n  }\n}\n\n// Full int32 range is -0x80000000 to 0x7FFFFFFF. Use half.\n@inline function applyCap(x: i32): i32 {\n  return x < -0x40000000 ? -0x40000000 : (x > 0x3FFFFFFF ? 0x3FFFFFFF : x);\n}\n\n@inline function toRGB(x: i32): i32 {\n  // Map negative values to red, positive to blue-green, zero to black\n  var val = x >> 22;\n  if (val < 0) return ((-(val + 1))  | 0xFF000000); // red\n  return (((val << 8) | (val << 16)) | 0xFF000000); // cyan\n}\n\nconst STATUS_DEFAULT: i32 = 0;\nconst STATUS_WALL: i32 = 1;\nconst STATUS_POS_TRANSMITTER: i32 = 2;\nconst STATUS_NEG_TRANSMITTER: i32 = 3;\n\nconst FORCE_DAMPING_BIT_SHIFT: i32 = 4;\n\nlet width:  i32 = 0;\nlet height: i32 = 0;\nlet area:   i32 = 0;\n\nlet image:  Pointer;\nlet force:  Pointer;\nlet status: Pointer;\nlet u:      Pointer;\nlet v:      Pointer;\n\nexport function init(_ignored: i32, offset: i32, w: i32, h: i32): void {\n\n  width  = w;\n  height = h;\n  area   = width * height;\n  image  = new Pointer(offset);\n  force  = new Pointer(offset + 4  * area);\n  status = new Pointer(offset + 8  * area);\n  u      = new Pointer(offset + 12 * area);\n  v      = new Pointer(offset + 16 * area);\n\n  for (let i = 0; i < height; ++i) {\n    status[i * width] = STATUS_WALL;\n    status[i * width + width - 1] = STATUS_WALL;\n  }\n\n  for (let i = 0; i < width; ++i) {\n    status[i] = STATUS_WALL;\n    status[area - width + i] = STATUS_WALL;\n  }\n}\n\nexport function step(signalAmplitude: i32, dampingBitShift: i32): void {\n  let _area = area,\n    _status = status,\n    _u = u,\n    _v = v,\n    _force = force,\n    _image = image,\n    _width = width;\n\n  // First loop: look for noise generator pixels and set their values in u\n  for (let i = 0; i < _area; ++i) {\n    let s = _status[i];\n    if (s === STATUS_POS_TRANSMITTER) {\n      _u[i] = signalAmplitude;\n      _v[i] = 0;\n      _force[i] = 0;\n    }\n    if (s === STATUS_NEG_TRANSMITTER) {\n      _u[i] = -signalAmplitude;\n      _v[i] = 0;\n      _force[i] = 0;\n    }\n  }\n\n  for (let i = 0; i < _area; ++i) {\n    if (_status[i] === STATUS_DEFAULT) {\n      let uCen   = _u[i];\n      let uNorth = _u[i - _width];\n      let uSouth = _u[i + _width];\n      let uEast  = _u[i + 1];\n      let uWest  = _u[i - 1];\n\n      let uxx = (((uWest  + uEast)  >> 1) - uCen);\n      let uyy = (((uNorth + uSouth) >> 1) - uCen);\n\n      let vel = _v[i] + (uxx >> 1) + (uyy >> 1);\n      if (dampingBitShift) vel -= vel >> dampingBitShift;\n      _v[i] = applyCap(vel);\n    }\n  }\n\n  let stat: i32, f: i32, capped: i32, u: i32;\n  for (let i = 0; i < _area; ++i) {\n    stat = _status[i];\n    if (stat === STATUS_DEFAULT) {\n      f = _force[i];\n      u = _u[i];\n      capped = applyCap(u + _v[i]);\n      u = applyCap(f + capped);\n      _u[i] = u;\n      _force[i] = f - (f >> FORCE_DAMPING_BIT_SHIFT);\n    }\n    if (stat === STATUS_WALL) {\n      _image[i] = 0x00000000;\n    } else {\n      _image[i] = toRGB(u);\n    }\n  }\n}\n"]}